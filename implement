/* Includes, system */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* Includes, cuda */
#include "cublas_v2.h"
#include <cuda_runtime.h>

#define N 10
#define MAX_ITER 100
#define EPSILON 1e-6

int main() {
    cublasHandle_t handle;
    cublasCreate(&handle);

    int n = N;
    int size = n * sizeof(double);

    // Host memory
    double *h_A = (double *)malloc(n * n * sizeof(double));
    double *h_b = (double *)malloc(size);
    double *h_x = (double *)malloc(size);

    // Initialize matrix A and vector b
    for (int i = 0; i < n; ++i) {
        h_b[i] = 1.0;
        h_x[i] = 0.0;
        for (int j = 0; j < n; ++j) {
            h_A[i * n + j] = (i == j) ? 2.0 : 1.0;
        }
    }

    // Device memory
    double *d_A, *d_b, *d_x, *d_r, *d_p, *d_Ap, *d_tmp;
    cudaMalloc((void **)&d_A, n * n * sizeof(double));
    cudaMalloc((void **)&d_b, size);
    cudaMalloc((void **)&d_x, size);
    cudaMalloc((void **)&d_r, size);
    cudaMalloc((void **)&d_p, size);
    cudaMalloc((void **)&d_Ap, size);
    cudaMalloc((void **)&d_tmp, size);

    cudaMemcpy(d_A, h_A, n * n * sizeof(double), cudaMemcpyHostToDevice);
    cudaMemcpy(d_b, h_b, size, cudaMemcpyHostToDevice);
    cudaMemcpy(d_x, h_x, size, cudaMemcpyHostToDevice);

    double zero = 0.0, one = 1.0, minusOne = -1.0;
    double alpha = 0, beta = 0, rxr = 0, tmp;

    // r0 = b - A*x0
    cublasDcopy(handle, n, d_b, 1, d_r, 1);
    cublasDgemv(handle, CUBLAS_OP_N, n, n, &minusOne, d_A, n, d_x, 1, &one, d_r, 1);

    // p0 = r0
    cublasDcopy(handle, n, d_r, 1, d_p, 1);

    int k = 0;
    while (k < MAX_ITER) {
        // Ap = A * p
        cublasDgemv(handle, CUBLAS_OP_N, n, n, &one, d_A, n, d_p, 1, &zero, d_Ap, 1);

        // tmp = dot(r, r)
        cublasDdot(handle, n, d_r, 1, d_r, 1, &rxr);

        // alpha = rxr / dot(p, Ap)
        cublasDdot(handle, n, d_p, 1, d_Ap, 1, &tmp);
        alpha = rxr / tmp;

        // x = x + alpha * p
        cublasDaxpy(handle, n, &alpha, d_p, 1, d_x, 1);

        // r = r - alpha * Ap
        tmp = -alpha;
        cublasDaxpy(handle, n, &tmp, d_Ap, 1, d_r, 1);

        // check convergence
        double new_rxr;
        cublasDdot(handle, n, d_r, 1, d_r, 1, &new_rxr);
        if (sqrt(new_rxr) < EPSILON) break;

        // beta = new_rxr / rxr
        beta = new_rxr / rxr;
        rxr = new_rxr;

        // p = r + beta * p
        cublasDscal(handle, n, &beta, d_p, 1);
        cublasDaxpy(handle, n, &one, d_r, 1, d_p, 1);

        ++k;
    }

    cudaMemcpy(h_x, d_x, size, cudaMemcpyDeviceToHost);

    printf("Converged in %d iterations\n", k);
    for (int i = 0; i < n; ++i) {
        printf("x[%d] = %f\n", i, h_x[i]);
    }

    // Free resources
    cudaFree(d_A); cudaFree(d_b); cudaFree(d_x); cudaFree(d_r);
    cudaFree(d_p); cudaFree(d_Ap); cudaFree(d_tmp);
    free(h_A); free(h_b); free(h_x);
    cublasDestroy(handle);

    return 0;
}
