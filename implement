#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <cuda_runtime.h>
#include <cublas_v2.h>

#define N 10
#define MAX_ITER 1000
#define EPSILON 1e-6

int main() {
    cublasHandle_t handle;
    cublasCreate(&handle);

    // Host memory
    float *h_A = (float*)malloc(N * N * sizeof(float));
    float *h_b = (float*)malloc(N * sizeof(float));
    float *h_x = (float*)malloc(N * sizeof(float));

    // Device memory
    float *d_A, *d_b, *d_x, *d_r, *d_p, *d_Ap;
    cudaMalloc((void**)&d_A, N * N * sizeof(float));
    cudaMalloc((void**)&d_b, N * sizeof(float));
    cudaMalloc((void**)&d_x, N * sizeof(float));
    cudaMalloc((void**)&d_r, N * sizeof(float));
    cudaMalloc((void**)&d_p, N * sizeof(float));
    cudaMalloc((void**)&d_Ap, N * sizeof(float));

    // Initialize matrix A (symmetric positive-definite) and vector b
    for (int i = 0; i < N * N; ++i) {
        h_A[i] = (i % (N + 1) == 0) ? 4.0f : 1.0f;  // Diagonally dominant
    }
    for (int i = 0; i < N; ++i) {
        h_b[i] = 1.0f;
        h_x[i] = 0.0f;
    }

    // Copy to device
    cublasSetVector(N * N, sizeof(float), h_A, 1, d_A, 1);
    cublasSetVector(N, sizeof(float), h_b, 1, d_b, 1);
    cublasSetVector(N, sizeof(float), h_x, 1, d_x, 1);

    // Scalar constants
    const float zero = 0.0f, minusOne = -1.0f, one = 1.0f;
    float alpha = 0.0f, beta = 0.0f;
    float rxr = 0.0f, tmp = 0.0f;

    // r0 = b
    cublasScopy(handle, N, d_b, 1, d_r, 1);

    // r0 = b - A * x0
    cublasSgemv(handle, CUBLAS_OP_N, N, N, &minusOne, d_A, N, d_x, 1, &one, d_r, 1);

    // p0 = r0
    cublasScopy(handle, N, d_r, 1, d_p, 1);

    // rxr = r^T * r
    cublasSdot(handle, N, d_r, 1, d_r, 1, &rxr);

    int k = 0;
    while (k < MAX_ITER) {
        // A * p
        cublasSgemv(handle, CUBLAS_OP_N, N, N, &one, d_A, N, d_p, 1, &zero, d_Ap, 1);

        // p^T * A * p
        cublasSdot(handle, N, d_p, 1, d_Ap, 1, &tmp);

        // alpha = rxr / tmp
        alpha = rxr / tmp;

        // x = x + alpha * p
        cublasSaxpy(handle, N, &alpha, d_p, 1, d_x, 1);

        // r = r - alpha * Ap
        float neg_alpha = -alpha;
        cublasSaxpy(handle, N, &neg_alpha, d_Ap, 1, d_r, 1);

        // tmp = r^T * r
        cublasSdot(handle, N, d_r, 1, d_r, 1, &tmp);

        // convergence check
        if (sqrt(tmp) < EPSILON) break;

        beta = tmp / rxr;
        rxr = tmp;

        // p = r + beta * p
        cublasSscal(handle, N, &beta, d_p, 1);
        cublasSaxpy(handle, N, &one, d_r, 1, d_p, 1);

        ++k;
    }

    // Copy result back
    cublasGetVector(N, sizeof(float), d_x, 1, h_x, 1);

    printf("Solution x (after %d iterations):\n", k);
    for (int i = 0; i < N; ++i) {
        printf("%f ", h_x[i]);
    }
    printf("\n");

    // Cleanup
    free(h_A); free(h_b); free(h_x);
    cudaFree(d_A); cudaFree(d_b); cudaFree(d_x);
    cudaFree(d_r); cudaFree(d_p); cudaFree(d_Ap);
    cublasDestroy(handle);

    return 0;
}
